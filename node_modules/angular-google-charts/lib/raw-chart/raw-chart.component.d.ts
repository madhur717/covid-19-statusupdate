/// <reference types="google.visualization" />
import { EventEmitter, ElementRef, OnInit, OnChanges, AfterViewInit } from '@angular/core';
import { Observable } from 'rxjs';
import { ChartErrorEvent, ChartEvent } from '../models/events.model';
import { ScriptLoaderService } from '../script-loader/script-loader.service';
import * as ɵngcc0 from '@angular/core';
export declare class RawChartComponent implements OnInit, OnChanges, AfterViewInit {
    protected element: ElementRef;
    protected loaderService: ScriptLoaderService;
    chartData: google.visualization.ChartSpecs;
    formatter: google.visualization.DefaultFormatter | Array<{
        formatter: google.visualization.DefaultFormatter;
        colIndex: number;
    }>;
    dynamicResize: boolean;
    firstRowIsData: boolean;
    error: EventEmitter<ChartErrorEvent>;
    ready: EventEmitter<{}>;
    select: EventEmitter<ChartEvent>;
    mouseenter: EventEmitter<ChartEvent>;
    mouseleave: EventEmitter<ChartEvent>;
    wrapper: google.visualization.ChartWrapper;
    private dataTable;
    constructor(element: ElementRef, loaderService: ScriptLoaderService);
    ngOnInit(): void;
    ngAfterViewInit(): void;
    ngOnChanges(): void;
    getChartElement(): HTMLElement;
    protected createChart(): void;
    protected loadNeededPackages(): Observable<void>;
    protected updateChart(): void;
    protected formatData(dataTable: google.visualization.DataTable): void;
    private addResizeListener;
    private removeChartEvents;
    private registerChartEvents;
    private registerChartEvent;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<RawChartComponent, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<RawChartComponent, "raw-chart", ["raw-chart"], { "dynamicResize": "dynamicResize"; "firstRowIsData": "firstRowIsData"; "chartData": "chartData"; "formatter": "formatter"; }, { "error": "error"; "ready": "ready"; "select": "select"; "mouseenter": "mouseenter"; "mouseleave": "mouseleave"; }, never, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmF3LWNoYXJ0LmNvbXBvbmVudC5kLnRzIiwic291cmNlcyI6WyJyYXctY2hhcnQuY29tcG9uZW50LmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiLy8vIDxyZWZlcmVuY2UgdHlwZXM9XCJnb29nbGUudmlzdWFsaXphdGlvblwiIC8+XHJcbmltcG9ydCB7IEV2ZW50RW1pdHRlciwgRWxlbWVudFJlZiwgT25Jbml0LCBPbkNoYW5nZXMsIEFmdGVyVmlld0luaXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBDaGFydEVycm9yRXZlbnQsIENoYXJ0RXZlbnQgfSBmcm9tICcuLi9tb2RlbHMvZXZlbnRzLm1vZGVsJztcclxuaW1wb3J0IHsgU2NyaXB0TG9hZGVyU2VydmljZSB9IGZyb20gJy4uL3NjcmlwdC1sb2FkZXIvc2NyaXB0LWxvYWRlci5zZXJ2aWNlJztcclxuZXhwb3J0IGRlY2xhcmUgY2xhc3MgUmF3Q2hhcnRDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIE9uQ2hhbmdlcywgQWZ0ZXJWaWV3SW5pdCB7XHJcbiAgICBwcm90ZWN0ZWQgZWxlbWVudDogRWxlbWVudFJlZjtcclxuICAgIHByb3RlY3RlZCBsb2FkZXJTZXJ2aWNlOiBTY3JpcHRMb2FkZXJTZXJ2aWNlO1xyXG4gICAgY2hhcnREYXRhOiBnb29nbGUudmlzdWFsaXphdGlvbi5DaGFydFNwZWNzO1xyXG4gICAgZm9ybWF0dGVyOiBnb29nbGUudmlzdWFsaXphdGlvbi5EZWZhdWx0Rm9ybWF0dGVyIHwgQXJyYXk8e1xyXG4gICAgICAgIGZvcm1hdHRlcjogZ29vZ2xlLnZpc3VhbGl6YXRpb24uRGVmYXVsdEZvcm1hdHRlcjtcclxuICAgICAgICBjb2xJbmRleDogbnVtYmVyO1xyXG4gICAgfT47XHJcbiAgICBkeW5hbWljUmVzaXplOiBib29sZWFuO1xyXG4gICAgZmlyc3RSb3dJc0RhdGE6IGJvb2xlYW47XHJcbiAgICBlcnJvcjogRXZlbnRFbWl0dGVyPENoYXJ0RXJyb3JFdmVudD47XHJcbiAgICByZWFkeTogRXZlbnRFbWl0dGVyPHt9PjtcclxuICAgIHNlbGVjdDogRXZlbnRFbWl0dGVyPENoYXJ0RXZlbnQ+O1xyXG4gICAgbW91c2VlbnRlcjogRXZlbnRFbWl0dGVyPENoYXJ0RXZlbnQ+O1xyXG4gICAgbW91c2VsZWF2ZTogRXZlbnRFbWl0dGVyPENoYXJ0RXZlbnQ+O1xyXG4gICAgd3JhcHBlcjogZ29vZ2xlLnZpc3VhbGl6YXRpb24uQ2hhcnRXcmFwcGVyO1xyXG4gICAgcHJpdmF0ZSBkYXRhVGFibGU7XHJcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50OiBFbGVtZW50UmVmLCBsb2FkZXJTZXJ2aWNlOiBTY3JpcHRMb2FkZXJTZXJ2aWNlKTtcclxuICAgIG5nT25Jbml0KCk6IHZvaWQ7XHJcbiAgICBuZ0FmdGVyVmlld0luaXQoKTogdm9pZDtcclxuICAgIG5nT25DaGFuZ2VzKCk6IHZvaWQ7XHJcbiAgICBnZXRDaGFydEVsZW1lbnQoKTogSFRNTEVsZW1lbnQ7XHJcbiAgICBwcm90ZWN0ZWQgY3JlYXRlQ2hhcnQoKTogdm9pZDtcclxuICAgIHByb3RlY3RlZCBsb2FkTmVlZGVkUGFja2FnZXMoKTogT2JzZXJ2YWJsZTx2b2lkPjtcclxuICAgIHByb3RlY3RlZCB1cGRhdGVDaGFydCgpOiB2b2lkO1xyXG4gICAgcHJvdGVjdGVkIGZvcm1hdERhdGEoZGF0YVRhYmxlOiBnb29nbGUudmlzdWFsaXphdGlvbi5EYXRhVGFibGUpOiB2b2lkO1xyXG4gICAgcHJpdmF0ZSBhZGRSZXNpemVMaXN0ZW5lcjtcclxuICAgIHByaXZhdGUgcmVtb3ZlQ2hhcnRFdmVudHM7XHJcbiAgICBwcml2YXRlIHJlZ2lzdGVyQ2hhcnRFdmVudHM7XHJcbiAgICBwcml2YXRlIHJlZ2lzdGVyQ2hhcnRFdmVudDtcclxufVxyXG4iXX0=